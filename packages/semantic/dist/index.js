var o=e=>["@semantic-release/commit-analyzer",{releaseRules:[...e]}];var l=e=>["@semantic-release/git",{assets:typeof e.gitAssets=="boolean"?!1:["package.json"].concat(e.gitAssets?e.gitAssets:[]).filter(s=>s),message:e.message?e.message:"chore(release): `${nextRelease.gitTag}` [skip ci] \n\n${nextRelease.notes}"}];var r=e=>{let s=e&&Object.values(e).filter(i=>typeof i<"u").length===0;if(!e||s)return["@semantic-release/github",{addReleases:!1,labels:!1,releasedLabels:!1,successComment:!1}];let{githubAssets:t,...a}=e;return["@semantic-release/github",{assets:t,addReleases:!1,labels:!1,releasedLabels:!1,successComment:!1,...a}]};var m=e=>!e||typeof e.pkgRoot!="string"&&typeof e.npmPublish!="boolean"&&typeof e.tarballDir>"u"?"@semantic-release/npm":["@semantic-release/npm",{...e}];var N=["@semantic-release/release-notes-generator"],z=["@jeromefitz/release-notes-generator",{config:"@jeromefitz/conventional-gitmoji"}],n=e=>{let t={...{enableGit:!1,enableGithub:!0,enableNpm:!0,enableReleaseNotes:!1,enableReleaseNotesCustom:!0,pkgRoot:"./dist"},...e},{npmPublish:a,pkgRoot:i,tarballDir:g}=t,p=m({npmPublish:a,pkgRoot:i,tarballDir:g}),{addReleases:f,assignees:u,failComment:b,failTitle:y,githubApiPathPrefix:h,githubAssets:P,githubUrl:R,labels:x,proxy:d,releasedLabels:S}=t,C=r({addReleases:f,assignees:u,failComment:b,failTitle:y,githubApiPathPrefix:h,githubAssets:P,githubUrl:R,labels:x,proxy:d,releasedLabels:S}),O=l(t);return[o(t.releaseRules),t.enableReleaseNotes?N:"",t.enableReleaseNotesCustom?z:"",t.enableNpm?p:"",t.enableGithub?C:"",t.enableGit?O:""].filter(A=>!!A)};var c=(e={})=>{let s=n(e);return{...{branches:[{name:"main"},{name:"canary",prerelease:"canary"}],extends:["semantic-release-commit-filter"],plugins:s,tagFormat:"v${version}"},...e}};var K=n(),M=c();export{M as config,c as getConfig,n as getPluginOptions,K as plugins};
