var i=e=>["@semantic-release/commit-analyzer",{releaseRules:[...e]}];var l=e=>["@semantic-release/git",{assets:typeof e.gitAssets=="boolean"?!1:["package.json"].concat(e.gitAssets?e.gitAssets:[]).filter(s=>s),message:e.message?e.message:"chore(release): `${nextRelease.gitTag}` [skip ci] \n\n${nextRelease.notes}"}];var o=e=>{let s=e&&Object.values(e).filter(a=>typeof a<"u").length===0;if(!e||s)return["@semantic-release/github",{addReleases:!1,labels:!1,releasedLabels:!1,successComment:!1}];let{githubAssets:t,...n}=e;return["@semantic-release/github",{assets:t,addReleases:!1,labels:!1,releasedLabels:!1,successComment:!1,...n}]};var r=e=>!e||typeof e.pkgRoot!="string"&&typeof e.npmPublish!="boolean"&&typeof e.tarballDir>"u"?"@semantic-release/npm":["@semantic-release/npm",{...e}];var O=["@semantic-release/release-notes-generator"],z=["@jeromefitz/release-notes-generator",{config:"@jeromefitz/conventional-gitmoji"}],m=e=>{let t={...{enableGit:!1,enableGithub:!0,enableNpm:!0,enableReleaseNotes:!1,enableReleaseNotesCustom:!0,pkgRoot:"./dist"},...e},{npmPublish:n,pkgRoot:a,tarballDir:g}=t,p=r({npmPublish:n,pkgRoot:a,tarballDir:g}),{addReleases:f,assignees:u,failComment:b,failTitle:y,githubApiPathPrefix:h,githubAssets:R,githubUrl:x,labels:P,proxy:d,releasedLabels:S}=t,C=o({addReleases:f,assignees:u,failComment:b,failTitle:y,githubApiPathPrefix:h,githubAssets:R,githubUrl:x,labels:P,proxy:d,releasedLabels:S}),A=l(t);return[i(t.releaseRules),t.enableReleaseNotes?O:"",t.enableReleaseNotesCustom?z:"",t.enableNpm?p:"",t.enableGithub?C:"",t.enableGit?A:""].filter(N=>!!N)};var c=(e={})=>{let s=m(e);return{...{branches:[{name:"main"},{name:"canary",prerelease:"canary"}],extends:["semantic-release-commit-filter"],plugins:s,tagFormat:"v${version}"},...e}};var j=c(),K=j;export{K as default};
